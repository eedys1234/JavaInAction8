# JavaInAction8

## `Chapter 2`
- #### 동적 파라미터화
- #### 익명 클래스
- #### 람다 표현식 미리보기

동적 파라미터화란 어떻게 실행할 것인지 결정하지 않은 **코드 블록**을 의미한다. 즉, 코드 블록에 대한 실행을 나중으로 미룬다. 
예를들어 컬렉션을 처리할 때, 다음과 같은 메서드를 구현한다고 가정하자
- 리스트의 모든 요소에 대해서 어떤 동작을 수행할 수 있음
- 리스트 관련 작업을 끝낸 다음에 어떤 다른 동작을 수행할 수 있음
- 에러가 발생하면 정해진 어떤 다른 동작을 수행할 수 있음

여기서 어떤 다른 동작, 어떤 다른 동작을 코드 블록화하여 메서드의 인수로 전달한다. 어떤 동작을 코드 블록화 하는 방법에는 자바8 이전에는 인터페이스를 구현한 클래스 혹은 익명 클래스를 통해 전달하는 방법이 있으며 이와 관련된 패턴으로는 전략패턴이 존재한다. 인터페이스를 구현하는 클래스 혹은 익명 클래스를 전달하는 방법은 코드가 장황해질 수 있는 단점이 존재한다. 장황한 코드를 간결하고 가독성있는 코드로 변경해주는 방안에는 자바 8의 람다표현식 or 메서드 참조가 존재한다.
즉, 동적 파라미터화를 추상화하여 사용함으로써 변화하는 요구사항에 유연하게 대응하며 간결하게 코드를 작성할 수 있는 장점이 존재한다.

## `Chapter 3`
- #### 람다란 무엇인가?
- #### 실행 어라운드 패턴
- #### 함수형 인터페이스, 형식 추론
- #### 메서드 참조

---  
**3.1.1 람다란 무엇인가?**

람다표현식은 메서드로 전달할 수 있는 익명함수를 단순화한 것이며 람다표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외리스트를 가질 수 있다.  
람다표현식은 파라미터, 화살표, 바디로 이루어진다.  
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());  

**3.1.2. 실행 어라운드 패턴**
실제 자원을 처리하는 코드가 초기화와 정리 두 과정에 둘러쌓여 있는 형태의 코드를 실행 어라운드 패턴이라고 부른다.

**3.1.3. 함수형 인터페이스**

함수형 인터페이스란 단 하나의 추상메서드를 지정하는 인터페이스이며 @FunctionalInterface 라는 애너테이션을 붙여준다.
함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 표현하는 메서드를 함수 디스크립터라고 부른다. 

**3.1.4 함수형 인터페이스, 형식추론**

람다 표현식은 함수형 인터페이스의 인스턴스를 만들 수 있다. 하지만 람다 표현식에는 함수형 인터페이스에 대한 정보가 포함되어 있지 않다. 그렇다면 어떻게 추론할 수 있는것일까?  
람다가 사용하는 콘텍스트를 이용해서 람다의 형식을 추론할 수 있다. 예를들면 콘텍스트에서 기대되는 람다 표현식의 형식을 대상형식이라고 한다. 
다음은 어떻게 형식을 추론하는지 보여준다.

1. 메서드의 인수 형식을 확인한다.(대상형식은 함수형 인터페이스)
2. 함수형 인터페이스의 추상 메서드를 확인한다.
3. 추상 메서드의 시그니처를 통해 람다 표현식의 함수 디스크립터와 비교한다.

람다 캡처링 : 람다 표현식에서는 외부변수를 참조할 수 있다. 이를 람다 캡처링이라 한다. 하지만 외부변수를 변경할 수 없는 제약이 존재하는데 람다를 실행하는 스레드에서 외부변수를 참조할 수 없는 상황이 발생할 수 있으므로 외부변수를 자신의 스택에 복사하는 형식으로 외부변수를 사용하기 때문이다. 그러므로 외부변수가 재할당 될 수 없다.

**3.1.5 메서드 참조**

메서드 참조는 람다 표현식을 축약한다.
메서드 참조는 세가지 유형으로 구분할 수 있는데 이는 다음과 같다.

1. 정적 메서드
2. 인스턴스 메서드
3. 외부변수 메서드

메서드 참조와 마찬가지로 생성자 또한 참조할 수 있으며 생성자의 참조는 함수형 인터페이스의 인스턴스로 할당된다.

## `Chapter 4`
- #### 스트림이란 무엇인가?
- #### 컬렉션과 스트림
- #### 내부 반복과 외부 반복
- #### 중간 연산과 최종 연산

---  
**4.1. 스트림이란 무엇인가?**
자바 8 API에 새로 추가된 기능으로 스트림을 이용하면 선언형으로 컬렉션 데이터를 처리할 수 있다. 스트림을 이용하면 복잡한 멀티 스레드 코드를 구현하지 않고 투명하게 병렬로 처리할 수 있다.

자바 8 이전 코드
```
List<Dish> lowCaloricDishes = new ArrayList<>();
for(Dish dish : menu) {
  if(dish.getCalories() < 400) {
     lowCaloricDishes.add(dish);
  }
}

Collections.sort(lowCaloricDishes, new Comparator<Dish>() {
    public int compare(Dish dish1, Dish dish2) {
      return Integer.compare(dish1.getCalories(), dish2.getCalories());
    }
});

List<String> lowCaloricDishedName = new ArrayList<>();
for(Dish dish : lowCaloricDishes) {
  lowCaloricDishesName.add(dish.getName());
}

``` 

자바 8 이후 코드
```

List<String> lowCaloricDishesName = menu.stream().filter(d -> d.getCalories() < 400)
                                                  .sorted(comparing(Dish::getCalories))
                                                  .map(Dish::getName)
                                                  .collect(toList());
                                                  
stream() 메서드를 parallelStream() 메서드로 변경하면 멀티코어 아키텍처에서 병렬로 실행 가능하다.
```

**4.2. 컬렉션과 스트림**

연속된 요소의 형식을 순차적으로 접근하는 것이 컬렉션과 스트림의 공통점이다. 그렇다면 컬렉션과 스트림의 차이점은 무엇일까?  
컬렉션은 모든 요소를 계산하여 메모리에 저장하는 반면 스트림은 요청할 때만 요소를 계산하는 고정된 자료구조이다.  
스트림은 딱 한번 소비하면 재사용할 수 없으며 컬렉션은 여러 번 사용할 수 있다. 마지막으로는 데이터 반복처리 방법이다.  
컬렉션을 사용하면 사용자가 직접 반복을 처리해줘야하며 이를 외부 반복이라 한다. 반면 스트림은 라이브러리 내에서 내부 반보글 사용하여 알아서 처리해준다.


**4.3. 외부 반복과 내부 반복**

컬렉션은 외부 반복을 통해 컬렉션의 모든 요소에 접근한다. (사용자가 직접적으로 반복자를 명시해야함 iterator)
스트림은 내부 반복을 통해 (반복을 감춤) 모든 요소에 접근한다. 
반복을 감춤으로써 멀티 프로세서 환경을 쉽게 구현할 수 있는 장점이 존재한다.

**4.4. 중간 연산과 최종 연산**

중간 연산은 연산결과 다른 스트림을 리턴하며 파이프라인을 구축한다. 대표적인 메서드로는 map, filter, sorted, distinct 등이 존재한다.
최종 연산은 구축된 파이프라인을 실행하며 스트림을 닫는다. 대표적인 메서드로는 count, collect 등이 존재한다.


## `Chapter 5` 

- #### 필터링, 슬라이싱, 매칭
- #### 검색, 매칭, 리듀싱
- #### 특정 범위의 숫자와 같은 숫자 스트림 사용
- #### 다중 소스로부터 스트림 만들기
- #### 무한 스트림

---


